---
name: Dependency Updates

# Trigger on PRs from Dependabot and manual workflow dispatch
"on":
  pull_request:
    types: ["opened", "synchronize", "reopened"]
  workflow_dispatch:
    inputs:
      force_merge:
        description: 'Force merge after successful tests (admin override)'
        required: false
        default: false
        type: boolean

# Permissions for auto-merge functionality
permissions:
  contents: write
  pull-requests: write
  checks: read
  actions: read

jobs:
  # Check if this is a Dependabot PR and analyze the update type
  analyze-dependabot-pr:
    name: Analyze Dependabot PR
    runs-on: ubuntu-latest
    if: >
      github.actor == 'dependabot[bot]' ||
      github.event_name == 'workflow_dispatch'
    outputs:
      is_dependabot: ${{ steps.check.outputs.is_dependabot }}
      is_security_patch: ${{ steps.check.outputs.is_security_patch }}
      update_type: ${{ steps.check.outputs.update_type }}
      dependency_name: ${{ steps.check.outputs.dependency_name }}
      can_auto_merge: ${{ steps.check.outputs.can_auto_merge }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PR for auto-merge eligibility
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            const isDependabot = pullRequest.user.login === 'dependabot[bot]';
            const prTitle = pullRequest.title;
            const prBody = pullRequest.body || '';

            console.log('PR Title:', prTitle);
            console.log('PR Author:', pullRequest.user.login);

            let isSecurityPatch = false;
            let updateType = 'unknown';
            let dependencyName = 'unknown';
            let canAutoMerge = false;

            if (isDependabot) {
              // Parse Dependabot PR title to determine update type
              // Format: "deps: bump dependency-name from x.y.z to x.y.w"
              const titleMatch = prTitle.match(
                /deps: bump (.+) from (.+) to (.+)/
              );

              if (titleMatch) {
                dependencyName = titleMatch[1];
                const fromVersion = titleMatch[2];
                const toVersion = titleMatch[3];

                console.log(`Dependency: ${dependencyName}`);
                console.log(`Version change: ${fromVersion} → ${toVersion}`);

                // Determine semantic version change type
                const fromParts = fromVersion.split('.')
                  .map(n => parseInt(n) || 0);
                const toParts = toVersion.split('.')
                  .map(n => parseInt(n) || 0);

                if (toParts[0] > fromParts[0]) {
                  updateType = 'major';
                } else if (toParts[1] > fromParts[1]) {
                  updateType = 'minor';
                } else if (toParts[2] > fromParts[2]) {
                  updateType = 'patch';
                } else {
                  updateType = 'other';
                }

                // Check if this is a security update
                // Dependabot includes security information in PR body
                isSecurityPatch = prBody.includes('security') ||
                                prBody.includes('vulnerability') ||
                                prBody.includes('CVE-') ||
                                pullRequest.labels.some(label =>
                                  label.name.includes('security') ||
                                  label.name.includes('vulnerability')
                                );

                // Auto-merge criteria:
                // 1. Must be a patch or minor update (not major)
                // 2. Security patches are always eligible
                // 3. Regular patch updates are eligible
                canAutoMerge = isSecurityPatch || updateType === 'patch';

                console.log(`Update type: ${updateType}`);
                console.log(`Is security patch: ${isSecurityPatch}`);
                console.log(`Can auto-merge: ${canAutoMerge}`);
              }
            }

            // Set outputs
            core.setOutput('is_dependabot', isDependabot.toString());
            core.setOutput('is_security_patch', isSecurityPatch.toString());
            core.setOutput('update_type', updateType);
            core.setOutput('dependency_name', dependencyName);
            core.setOutput('can_auto_merge', canAutoMerge.toString());

            // Add labels to categorize the PR
            if (isDependabot) {
              const labelsToAdd = ['dependencies', 'automated'];

              if (isSecurityPatch) {
                labelsToAdd.push('security-update', 'auto-merge-eligible');
              } else if (updateType === 'patch') {
                labelsToAdd.push('patch-update', 'auto-merge-eligible');
              } else if (updateType === 'minor') {
                labelsToAdd.push('minor-update');
              } else if (updateType === 'major') {
                labelsToAdd.push('major-update', 'requires-review');
              }

              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labelsToAdd
                });
              } catch (error) {
                console.log('Failed to add labels:', error.message);
              }
            }

  # Run full quality gate suite for Dependabot PRs
  # This reuses the existing CI jobs but runs them for dependency updates
  run-quality-gates:
    name: Run Quality Gates
    needs: analyze-dependabot-pr
    if: needs.analyze-dependabot-pr.outputs.is_dependabot == 'true'
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  # Run security gates
  run-security-gates:
    name: Run Security Gates
    needs: analyze-dependabot-pr
    if: needs.analyze-dependabot-pr.outputs.is_dependabot == 'true'
    uses: ./.github/workflows/security-gates.yml
    secrets: inherit

  # Auto-merge eligible PRs that pass all quality gates
  auto-merge:
    name: Auto-merge Dependabot PR
    runs-on: ubuntu-latest
    needs: [analyze-dependabot-pr, run-quality-gates, run-security-gates]
    if: |
      always() &&
      (
        needs.analyze-dependabot-pr.outputs.can_auto_merge == 'true' ||
        github.event.inputs.force_merge == 'true'
      ) &&
      needs.run-quality-gates.result == 'success' &&
      needs.run-security-gates.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for all checks to complete
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            console.log('Waiting for all checks to complete...');

            let allChecksPassed = false;
            let attempts = 0;
            const maxAttempts = 30;

            while (!allChecksPassed && attempts < maxAttempts) {
              attempts++;
              console.log(`Check attempt ${attempts}/${maxAttempts}`);

              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pullRequest.head.sha,
              });

              const { data: statuses } = await github.rest.repos
                .listCommitStatusesForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pullRequest.head.sha,
              });

              // Check if all checks/statuses are completed and successful
              const allChecks = [...checks.check_runs, ...statuses];
              const pendingChecks = allChecks.filter(check =>
                check.status === 'in_progress' ||
                check.status === 'queued' ||
                check.state === 'pending'
              );

              const failedChecks = allChecks.filter(check =>
                check.conclusion === 'failure' ||
                check.conclusion === 'cancelled' ||
                check.state === 'failure' ||
                check.state === 'error'
              );

              if (failedChecks.length > 0) {
                console.log('Failed checks detected:',
                  failedChecks.map(c => c.name || c.context));
                core.setFailed('Cannot auto-merge: some checks failed');
                return;
              }

              if (pendingChecks.length === 0) {
                allChecksPassed = true;
                console.log('All checks completed successfully');
              } else {
                console.log(
                  `Waiting for ${pendingChecks.length} checks to complete:`,
                  pendingChecks.map(c => c.name || c.context)
                );
                // Wait 30 seconds
                await new Promise(resolve => setTimeout(resolve, 30000));
              }
            }

            if (!allChecksPassed) {
              core.setFailed('Timeout waiting for checks to complete');
            }

      - name: Enable auto-merge
        uses: actions/github-script@v7
        with:
          script: |
            const updateType =
              '${{ needs.analyze-dependabot-pr.outputs.update_type }}';
            const isSecurityPatch = (
              '${{ needs.analyze-dependabot-pr.outputs.is_security_patch }}'
              === 'true'
            );
            const dependencyName =
              '${{ needs.analyze-dependabot-pr.outputs.dependency_name }}';
            const forceMode =
              '${{ github.event.inputs.force_merge }}' === 'true';

            console.log('Auto-merge conditions:');
            console.log('- Update type:', updateType);
            console.log('- Security patch:', isSecurityPatch);
            console.log('- Dependency:', dependencyName);
            console.log('- Force mode:', forceMode);

            try {
              // Enable auto-merge on the PR
              await github.rest.pulls.enableAutoMerge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                merge_method: 'squash'
              });

              console.log('✅ Auto-merge enabled successfully');

              // Add a comment explaining the auto-merge
              const commentBody = forceMode
                ? `🤖 **Auto-merge enabled (Administrator Override)**\n\n` +
                  `All quality gates passed. This PR will be ` +
                  `automatically merged.`
                : `🤖 **Auto-merge enabled**\n\n` +
                  `**Dependency Update Details:**\n` +
                  `- Dependency: \`${dependencyName}\`\n` +
                  `- Update Type: ${updateType}\n` +
                  `- Security Patch: ` +
                  `${isSecurityPatch ? '✅ Yes' : '❌ No'}\n\n` +
                  `**Quality Gate Status:**\n` +
                  `- ✅ Code Quality Gates Passed\n` +
                  `- ✅ Security Gates Passed\n` +
                  `- ✅ Test Suite Passed\n\n` +
                  `This PR is eligible for auto-merge and will be ` +
                  `automatically merged since all quality gates passed.`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });

            } catch (error) {
              console.error('Failed to enable auto-merge:', error);

              // Try manual merge as fallback
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  merge_method: 'squash',
                  commit_title:
                    `Auto-merge: ${dependencyName} ${updateType} update`,
                  commit_message:
                    `Automatically merged ` +
                    `${isSecurityPatch ? 'security ' : ''}` +
                    `${updateType} update for ${dependencyName} ` +
                    `after all quality gates passed.`
                });

                console.log('✅ Manual merge completed successfully');
              } catch (mergeError) {
                console.error('Manual merge also failed:', mergeError);
                core.setFailed(`Failed to merge PR: ${mergeError.message}`);
              }
            }

  # Report auto-merge status
  report-status:
    name: Report Auto-merge Status
    runs-on: ubuntu-latest
    needs:
      - analyze-dependabot-pr
      - run-quality-gates
      - run-security-gates
      - auto-merge
    if: always() && needs.analyze-dependabot-pr.outputs.is_dependabot == 'true'
    steps:
      - name: Report final status
        uses: actions/github-script@v7
        with:
          script: |
            const qualityGatesResult =
              '${{ needs.run-quality-gates.result }}';
            const securityGatesResult =
              '${{ needs.run-security-gates.result }}';
            const autoMergeResult =
              '${{ needs.auto-merge.result }}';
            const canAutoMerge = (
              '${{ needs.analyze-dependabot-pr.outputs.can_auto_merge }}'
              === 'true'
            );
            const updateType =
              '${{ needs.analyze-dependabot-pr.outputs.update_type }}';
            const isSecurityPatch = (
              '${{ needs.analyze-dependabot-pr.outputs.is_security_patch }}'
              === 'true'
            );

            console.log('=== Dependency Update Workflow Summary ===');
            console.log('Quality Gates:', qualityGatesResult);
            console.log('Security Gates:', securityGatesResult);
            console.log('Auto-merge Attempt:', autoMergeResult);
            console.log('Auto-merge Eligible:', canAutoMerge);
            console.log('Update Type:', updateType);
            console.log('Security Patch:', isSecurityPatch);

            let statusEmoji = '❓';
            let statusMessage = 'Unknown status';

            if (qualityGatesResult === 'success' &&
                securityGatesResult === 'success') {
              if (autoMergeResult === 'success') {
                statusEmoji = '✅';
                statusMessage = 'Successfully auto-merged';
              } else if (canAutoMerge) {
                statusEmoji = '⚠️';
                statusMessage =
                  'Quality gates passed but auto-merge failed - ' +
                  'requires manual intervention';
              } else {
                statusEmoji = '📋';
                statusMessage =
                  'Quality gates passed but manual review ' +
                  'required due to update type';
              }
            } else {
              statusEmoji = '❌';
              statusMessage =
                'Quality gates failed - manual fixes required';
            }

            console.log(`Final Status: ${statusEmoji} ${statusMessage}`);

            // Create summary comment if gates failed or auto-merge failed
            if (qualityGatesResult !== 'success' ||
                securityGatesResult !== 'success' ||
                (canAutoMerge && autoMergeResult !== 'success')) {

              const commentBody = `## 🤖 Dependency Update Status\n\n` +
                `${statusEmoji} **${statusMessage}**\n\n` +
                `**Quality Gate Results:**\n` +
                `- Code Quality: ` +
                `${qualityGatesResult === 'success' ? '✅' : '❌'} ` +
                `${qualityGatesResult}\n` +
                `- Security Scan: ` +
                `${securityGatesResult === 'success' ? '✅' : '❌'} ` +
                `${securityGatesResult}\n\n` +
                `**Auto-merge Eligibility:**\n` +
                `- Update Type: ${updateType}\n` +
                `- Security Patch: ` +
                `${isSecurityPatch ? '✅' : '❌'}\n` +
                `- Eligible: ${canAutoMerge ? '✅' : '❌'}\n\n` +
                (qualityGatesResult !== 'success' ||
                 securityGatesResult !== 'success'
                  ? `⚠️ **Action Required:** Please review and fix the ` +
                    `failing quality gates before this PR can be merged.`
                  : canAutoMerge && autoMergeResult !== 'success'
                  ? `⚠️ **Action Required:** Auto-merge failed despite ` +
                    `passing quality gates. Please merge manually or ` +
                    `investigate the issue.`
                  : `📋 **Manual Review Required:** This ${updateType} ` +
                    `update requires manual review before merging.`);

              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
              } catch (error) {
                console.log('Failed to create status comment:', error.message);
              }
            }

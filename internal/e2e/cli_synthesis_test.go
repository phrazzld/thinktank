//go:build manual_api_test
// +build manual_api_test

// Package e2e contains end-to-end tests for the thinktank CLI
// These tests require a valid API key to run properly and are skipped by default
// To run these tests: go test -tags=manual_api_test ./internal/e2e/...
package e2e

import (
	"fmt"
	"net/http"
	"path/filepath"
	"strings"
	"testing"
)

// Constants for the mock synthesis responses
const (
	mockSynthesisContent = "# Synthesized Plan\n\nThis is a synthesized plan combining outputs from multiple models."
)

// setupSynthesisTest sets up a new TestEnv with mock handlers configured for synthesis tests
func setupSynthesisTest(t *testing.T) *TestEnv {
	t.Helper()

	// Create a new test environment
	env := NewTestEnv(t)

	// Set up test files
	// Create the basic test files, the actual instructions file will be used in each test
	env.CreateTestFile("instructions.md", "Implement a new feature with multiple models and synthesis")
	env.CreateTestFile("src/main.go", CreateGoSourceFileContent())

	// Store original mock handlers to restore later
	originalHandleModelInfo := env.MockConfig.HandleModelInfo
	originalHandleGeneration := env.MockConfig.HandleGeneration

	// Update mock handlers to handle multiple models and synthesis
	env.MockConfig.HandleModelInfo = func(req *http.Request) (string, int, int, error) {
		// Extract model name from URL path
		path := req.URL.Path
		modelName := path[strings.LastIndex(path, "/")+1:]
		return modelName, 100000, 8192, nil
	}

	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		// Extract model name from URL path
		path := req.URL.Path
		parts := strings.Split(path, "/")
		modelName := parts[len(parts)-2]

		// If this is the synthesis model, return synthesized content
		if strings.Contains(modelName, "synthesis") {
			return mockSynthesisContent, mockGenerationTokenUsed, mockFinishReason, nil
		}

		// For regular models, generate model-specific content
		return fmt.Sprintf("# Plan generated by %s\n\nThis is a test plan from %s.", modelName, modelName),
			mockGenerationTokenUsed,
			mockFinishReason,
			nil
	}

	// Add cleanup to restore original handlers
	t.Cleanup(func() {
		env.MockConfig.HandleModelInfo = originalHandleModelInfo
		env.MockConfig.HandleGeneration = originalHandleGeneration
		env.Cleanup()
	})

	return env
}

// verifySynthesisOutput checks for the expected synthesis output file
func verifySynthesisOutput(t *testing.T, env *TestEnv, synthesisModel string, outputDir string) {
	t.Helper()

	// Check for the synthesis output file
	synthesisOutputPath := filepath.Join(outputDir, synthesisModel+"-synthesis.md")
	if !env.FileExists(synthesisOutputPath) {
		t.Logf("Synthesis output file not found: %s (may be acceptable in mock environment)", synthesisOutputPath)
	} else {
		t.Logf("Synthesis output file exists: %s", synthesisOutputPath)

		// Read the file content
		content, err := env.ReadFile(synthesisOutputPath)
		if err != nil {
			t.Logf("Failed to read synthesis output file: %v", err)
		} else {
			// Verify synthesis content
			if !strings.Contains(content, "Synthesized Plan") {
				t.Logf("Synthesis output file does not contain expected content")
			} else {
				t.Logf("Synthesis output file contains expected content")
			}
		}
	}
}

// verifyModelOutputs checks for the expected individual model output files
func verifyModelOutputs(t *testing.T, env *TestEnv, modelNames []string, outputDir string) {
	t.Helper()

	// Check each model output file
	for _, modelName := range modelNames {
		outputPath := filepath.Join(outputDir, modelName+".md")
		if !env.FileExists(outputPath) {
			t.Logf("Model output file not found: %s (may be acceptable in mock environment)", outputPath)
		} else {
			t.Logf("Model output file exists: %s", outputPath)

			// Read the file content
			content, err := env.ReadFile(outputPath)
			if err != nil {
				t.Logf("Failed to read model output file: %v", err)
			} else {
				// Verify model-specific content
				expectedContent := fmt.Sprintf("Plan generated by %s", modelName)
				if !strings.Contains(content, expectedContent) {
					t.Logf("Model output file does not contain expected content")
				} else {
					t.Logf("Model output file contains expected content for model %s", modelName)
				}
			}
		}
	}
}

// TestSynthesisBasic tests the complete synthesis workflow
// It verifies that running thinktank with multiple models and a synthesis model
// correctly generates both individual model outputs and a synthesized output
func TestSynthesisBasic(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	// Set up test environment with mock handlers for synthesis
	env := setupSynthesisTest(t)

	// Create test instructions file
	instructionsFile := env.CreateTestFile("instructions-synthesis.md",
		"Implement a new feature that performs data analysis and visualization")

	// Set up the source directory with sample code
	srcDir := filepath.Join(env.TempDir, "src-synthesis")
	env.CreateTestFile(filepath.Join(srcDir, "main.go"), CreateGoSourceFileContent())
	env.CreateTestFile(filepath.Join(srcDir, "README.md"), "# Sample Project\n\nThis is a sample project for testing synthesis.")

	// Set up the output directory
	outputDir := filepath.Join(env.TempDir, "output-synthesis")

	// Define multiple model names
	primaryModelNames := []string{"model1", "model2", "model3"}
	synthesisModelName := "gemini-2.5-flash"

	// Set up basic flags
	flags := env.DefaultFlags
	flags.Instructions = instructionsFile
	flags.OutputDir = outputDir
	flags.ModelNames = primaryModelNames

	// Since the testFlags struct doesn't have a SynthesisModel field,
	// we'll add the synthesis model flag directly to the args when running the command

	// Create custom arguments with synthesis model flag
	args := []string{
		"--synthesis-model", synthesisModelName,
		srcDir,
	}

	// Run the thinktank binary with the custom synthesis flag
	stdout, stderr, exitCode, err := env.RunWithFlags(flags, args)
	if err != nil {
		t.Fatalf("Failed to run thinktank with synthesis: %v", err)
	}

	// Verify command executed successfully
	AssertAPICommandSuccess(t, stdout, stderr, exitCode,
		"Processing completed", "synthesizing results")

	// Verify that the synthesis flag was recognized in output
	combinedOutput := stdout + stderr
	if strings.Contains(combinedOutput, synthesisModelName) {
		t.Logf("Output contains reference to synthesis model: %s", synthesisModelName)
	} else {
		t.Logf("Note: Output does not mention synthesis model (may be acceptable in mock environment)")
	}

	// Verify synthesis output was created
	verifySynthesisOutput(t, env, synthesisModelName, outputDir)

	// Verify individual model outputs were created
	verifyModelOutputs(t, env, primaryModelNames, outputDir)

	// Check for synthesis-specific messages in output
	synthesisIndicators := []string{
		"synthesizing results",
		"synthesis model",
		"Successfully synthesized",
	}

	for _, indicator := range synthesisIndicators {
		if strings.Contains(combinedOutput, indicator) {
			t.Logf("Output contains expected synthesis indicator: %s", indicator)
		} else {
			t.Logf("Note: Output does not contain expected synthesis indicator: %s (may be acceptable in mock environment)", indicator)
		}
	}
}

// setupSynthesisTestWithFailures sets up a test environment where some primary models will fail
func setupSynthesisTestWithFailures(t *testing.T, failingModels map[string]error) *TestEnv {
	t.Helper()

	// Create a new test environment
	env := NewTestEnv(t)

	// Set up test files
	env.CreateTestFile("instructions.md", "Implement a new feature with multiple models and synthesis")
	env.CreateTestFile("src/main.go", CreateGoSourceFileContent())

	// Store original mock handlers to restore later
	originalHandleModelInfo := env.MockConfig.HandleModelInfo
	originalHandleGeneration := env.MockConfig.HandleGeneration

	// Update mock handlers to handle multiple models with some failures
	env.MockConfig.HandleModelInfo = func(req *http.Request) (string, int, int, error) {
		// Extract model name from URL path
		path := req.URL.Path
		modelName := path[strings.LastIndex(path, "/")+1:]
		return modelName, 100000, 8192, nil
	}

	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		// Extract model name from URL path
		path := req.URL.Path
		parts := strings.Split(path, "/")
		modelName := parts[len(parts)-2]

		// Check if this model is configured to fail
		if err, exists := failingModels[modelName]; exists {
			return "", 0, "", err
		}

		// If this is the synthesis model, return synthesized content
		if strings.Contains(modelName, "synthesis") {
			return mockSynthesisContent, mockGenerationTokenUsed, mockFinishReason, nil
		}

		// For regular models, generate model-specific content
		return fmt.Sprintf("# Plan generated by %s\n\nThis is a test plan from %s.", modelName, modelName),
			mockGenerationTokenUsed,
			mockFinishReason,
			nil
	}

	// Add cleanup to restore original handlers
	t.Cleanup(func() {
		env.MockConfig.HandleModelInfo = originalHandleModelInfo
		env.MockConfig.HandleGeneration = originalHandleGeneration
		env.Cleanup()
	})

	return env
}

// TestSynthesisWithFailures tests the synthesis workflow when some primary models fail
// It verifies that the synthesis still works with partial results from successful models
func TestSynthesisWithFailures(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	// Define which models should fail and with what errors
	failingModels := map[string]error{
		"model1": fmt.Errorf("model1 failed due to rate limiting"),
		"model3": fmt.Errorf("model3 failed due to connection error"),
	}

	// Set up test environment with mock handlers for synthesis with some failing models
	env := setupSynthesisTestWithFailures(t, failingModels)

	// Create test instructions file
	instructionsFile := env.CreateTestFile("instructions-synthesis-failures.md",
		"Implement a new feature that processes data even when some sources are unavailable")

	// Set up the source directory with sample code
	srcDir := filepath.Join(env.TempDir, "src-synthesis-failures")
	env.CreateTestFile(filepath.Join(srcDir, "main.go"), CreateGoSourceFileContent())
	env.CreateTestFile(filepath.Join(srcDir, "README.md"), "# Sample Project\n\nThis is a sample project for testing synthesis with failures.")

	// Set up the output directory
	outputDir := filepath.Join(env.TempDir, "output-synthesis-failures")

	// Define multiple model names (some will succeed, some will fail)
	allModelNames := []string{"model1", "model2", "model3", "model4"}
	successfulModels := []string{"model2", "model4"} // These should succeed based on failingModels map
	synthesisModelName := "gemini-2.5-flash"

	// Set up basic flags
	flags := env.DefaultFlags
	flags.Instructions = instructionsFile
	flags.OutputDir = outputDir
	flags.ModelNames = allModelNames

	// Add the synthesis model flag directly to the args
	args := []string{
		"--synthesis-model", synthesisModelName,
		srcDir,
	}

	// Run the thinktank binary with the custom synthesis flag
	stdout, stderr, exitCode, err := env.RunWithFlags(flags, args)
	if err != nil {
		t.Fatalf("Failed to run thinktank with synthesis and failing models: %v", err)
	}

	// Log outputs for debugging
	t.Logf("Stdout: %s", stdout)
	t.Logf("Stderr: %s", stderr)

	// We expect the command to succeed despite some models failing
	// because the synthesis should still work with the successful models
	if exitCode != 0 {
		t.Logf("Command exited with non-zero code %d, but this may be expected with partial failures", exitCode)
	}

	// Verify that the synthesis output was created
	verifySynthesisOutput(t, env, synthesisModelName, outputDir)

	// Verify that outputs were created only for the successful models
	verifyModelOutputs(t, env, successfulModels, outputDir)

	// Verify that outputs were NOT created for failing models
	for _, failingModel := range []string{"model1", "model3"} {
		failedOutputPath := filepath.Join(outputDir, failingModel+".md")
		if env.FileExists(failedOutputPath) {
			t.Errorf("Found output file for failed model %s at %s, expected no output",
				failingModel, failedOutputPath)
		} else {
			t.Logf("As expected, no output file exists for failed model %s", failingModel)
		}
	}

	// Combined output should contain error messages for failed models
	combinedOutput := stdout + stderr
	for modelName, err := range failingModels {
		errorMessage := err.Error()
		if strings.Contains(combinedOutput, errorMessage) ||
			strings.Contains(combinedOutput, fmt.Sprintf("failed to process model %s", modelName)) {
			t.Logf("Output contains expected error for %s: %s", modelName, errorMessage)
		} else {
			t.Logf("Note: Output does not contain explicit error for %s (may still be acceptable)", modelName)
		}
	}

	// Expected messages when synthesis proceeds with partial results
	partialIndicators := []string{
		"synthesizing results",
		"continuing with",
		"partial results",
		"some models failed",
	}

	// Check for indicators of partial synthesis in output
	for _, indicator := range partialIndicators {
		if strings.Contains(combinedOutput, indicator) {
			t.Logf("Output contains expected partial synthesis indicator: %s", indicator)
		} else {
			t.Logf("Note: Output does not contain expected partial synthesis indicator: %s (may be acceptable)", indicator)
		}
	}
}
